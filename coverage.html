
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/AlexMickh/coledzh-shop-backend/cmd/app/main.go (0.0%)</option>
				
				<option value="file1">github.com/AlexMickh/coledzh-shop-backend/cmd/create-admin/main.go (0.0%)</option>
				
				<option value="file2">github.com/AlexMickh/coledzh-shop-backend/cmd/env-setter/main.go (0.0%)</option>
				
				<option value="file3">github.com/AlexMickh/coledzh-shop-backend/internal/app/app.go (0.0%)</option>
				
				<option value="file4">github.com/AlexMickh/coledzh-shop-backend/internal/config/config.go (0.0%)</option>
				
				<option value="file5">github.com/AlexMickh/coledzh-shop-backend/internal/lib/email/email.go (0.0%)</option>
				
				<option value="file6">github.com/AlexMickh/coledzh-shop-backend/internal/repository/postgres/token/token.go (71.4%)</option>
				
				<option value="file7">github.com/AlexMickh/coledzh-shop-backend/internal/repository/postgres/user/user.go (61.3%)</option>
				
				<option value="file8">github.com/AlexMickh/coledzh-shop-backend/internal/repository/redis/session/session.go (66.7%)</option>
				
				<option value="file9">github.com/AlexMickh/coledzh-shop-backend/internal/server/handlers/auth/login/login.go (0.0%)</option>
				
				<option value="file10">github.com/AlexMickh/coledzh-shop-backend/internal/server/handlers/auth/register/register.go (63.3%)</option>
				
				<option value="file11">github.com/AlexMickh/coledzh-shop-backend/internal/server/server.go (0.0%)</option>
				
				<option value="file12">github.com/AlexMickh/coledzh-shop-backend/internal/services/auth/auth.go (71.0%)</option>
				
				<option value="file13">github.com/AlexMickh/coledzh-shop-backend/internal/services/token/token.go (80.0%)</option>
				
				<option value="file14">github.com/AlexMickh/coledzh-shop-backend/pkg/api/api.go (0.0%)</option>
				
				<option value="file15">github.com/AlexMickh/coledzh-shop-backend/pkg/clients/postgresql/postgresql.go (0.0%)</option>
				
				<option value="file16">github.com/AlexMickh/coledzh-shop-backend/pkg/clients/redis/redis.go (0.0%)</option>
				
				<option value="file17">github.com/AlexMickh/coledzh-shop-backend/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file18">github.com/AlexMickh/coledzh-shop-backend/pkg/session/session.go (0.0%)</option>
				
				<option value="file19">github.com/AlexMickh/coledzh-shop-backend/pkg/utils/retry/retry.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "io"
        "log/slog"
        "os"
        "os/signal"
        "syscall"

        "github.com/AlexMickh/coledzh-shop-backend/internal/app"
        "github.com/AlexMickh/coledzh-shop-backend/internal/config"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/logger"
)

func main() <span class="cov0" title="0">{
        cfg := config.MustLoad()

        file, err := os.OpenFile(cfg.Env+".log", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0666)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer file.Close()

        log := logger.New(cfg.Env, io.MultiWriter(os.Stdout, file))

        log.Info("logger is working", slog.String("env", cfg.Env))

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()
        ctx = logger.ContextWithLogger(ctx, log)

        app := app.New(ctx, cfg)
        app.Run(ctx)
        defer app.GracefulStop(ctx)

        stop := make(chan os.Signal, 1)
        signal.Notify(stop, syscall.SIGTERM, syscall.SIGINT)

        &lt;-stop

        close(stop)
        logger.FromCtx(ctx).Info("server stopped")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"

        "github.com/AlexMickh/coledzh-shop-backend/internal/config"
        user_repository "github.com/AlexMickh/coledzh-shop-backend/internal/repository/postgres/user"
        session_cash "github.com/AlexMickh/coledzh-shop-backend/internal/repository/redis/session"
        auth_service "github.com/AlexMickh/coledzh-shop-backend/internal/services/auth"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/clients/postgresql"
        redis_client "github.com/AlexMickh/coledzh-shop-backend/pkg/clients/redis"
)

func main() <span class="cov0" title="0">{
        var (
                login    string
                email    string
                password string
        )

        fmt.Print("Input login: ")
        fmt.Scan(&amp;login)
        fmt.Print("Input email: ")
        fmt.Scan(&amp;email)
        fmt.Print("Input password: ")
        fmt.Scan(&amp;password)

        cfg := config.MustLoad()

        db, err := postgresql.New(
                context.Background(),
                cfg.DB.User,
                cfg.DB.Password,
                cfg.DB.Host,
                cfg.DB.Port,
                cfg.DB.Name,
                cfg.DB.MinPools,
                cfg.DB.MaxPools,
                cfg.DB.MigrationsPath,
        )
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer db.Close()
        userRepository := user_repository.New(db)

        cash, err := redis_client.New(
                context.Background(),
                fmt.Sprintf("%s:%d", cfg.Redis.Host, cfg.Redis.Port),
                cfg.Redis.User,
                cfg.Redis.Password,
                cfg.Redis.DB,
        )
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">sessionCash := session_cash.New(cash, cfg.Redis.Expiration)

        authService := auth_service.New(userRepository, sessionCash)

        err = authService.RegisterAdmin(context.Background(), login, email, password)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">fmt.Printf("admin with login %s successfully created", login)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
        "io"
        "os"
        "reflect"

        "github.com/AlexMickh/coledzh-shop-backend/internal/config"
)

func main() <span class="cov0" title="0">{
        cfg := config.MustLoad()

        file, err := os.Create(".env")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = file.Close()
        }</span>()

        <span class="cov0" title="0">v := reflect.ValueOf(*cfg)

        processStruct(file, v)</span>
}

func processStruct(w io.Writer, v reflect.Value) <span class="cov0" title="0">{
        t := v.Type()

        for i := range v.NumField() </span><span class="cov0" title="0">{
                field := v.Field(i)

                if field.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                        processStruct(w, field)
                }</span> else<span class="cov0" title="0"> {
                        fieldValue := v.Field(i)
                        fieldType := t.Field(i)
                        tag := fieldType.Tag.Get("env")
                        if tag == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">_, err := fmt.Fprintf(w, "%s=%s\n", tag, fmt.Sprint(fieldValue))
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"
        "os"

        "github.com/AlexMickh/coledzh-shop-backend/internal/config"
        token_repository "github.com/AlexMickh/coledzh-shop-backend/internal/repository/postgres/token"
        user_repository "github.com/AlexMickh/coledzh-shop-backend/internal/repository/postgres/user"
        session_cash "github.com/AlexMickh/coledzh-shop-backend/internal/repository/redis/session"
        "github.com/AlexMickh/coledzh-shop-backend/internal/server"
        auth_service "github.com/AlexMickh/coledzh-shop-backend/internal/services/auth"
        token_service "github.com/AlexMickh/coledzh-shop-backend/internal/services/token"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/clients/postgresql"
        redis_client "github.com/AlexMickh/coledzh-shop-backend/pkg/clients/redis"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/logger"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/redis/go-redis/v9"
)

type App struct {
        srv *server.Server
        db  *pgxpool.Pool
        rdb *redis.Client
}

func New(ctx context.Context, cfg *config.Config) *App <span class="cov0" title="0">{
        const op = "app.New"

        log := logger.FromCtx(ctx).With(slog.String("op", op))

        log.Info("initing postgres")
        db, err := postgresql.New(
                ctx,
                cfg.DB.User,
                cfg.DB.Password,
                cfg.DB.Host,
                cfg.DB.Port,
                cfg.DB.Name,
                cfg.DB.MinPools,
                cfg.DB.MaxPools,
                cfg.DB.MigrationsPath,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to init postgres", logger.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">userRepository := user_repository.New(db)
        tokenRepository := token_repository.New(db)

        log.Info("initing redis")
        cash, err := redis_client.New(
                ctx,
                fmt.Sprintf("%s:%d", cfg.Redis.Host, cfg.Redis.Port),
                cfg.Redis.User,
                cfg.Redis.Password,
                cfg.Redis.DB,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to init redis", logger.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">sessionCash := session_cash.New(cash, cfg.Redis.Expiration)

        log.Info("initing service layer")
        authService := auth_service.New(userRepository, sessionCash)
        tokenService := token_service.New(tokenRepository)

        log.Info("initing server")
        srv := server.New(ctx, cfg.Server, authService, cfg.Mail, tokenService)

        return &amp;App{
                srv: srv,
                db:  db,
                rdb: cash,
        }</span>
}

func (a *App) Run(ctx context.Context) <span class="cov0" title="0">{
        const op = "app.Run"

        log := logger.FromCtx(ctx).With(slog.String("op", op))

        go func() </span><span class="cov0" title="0">{
                if err := a.srv.Run(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to start server", logger.Err(err))
                        os.Exit(1)
                }</span>
        }()

        <span class="cov0" title="0">log.Info("server started", slog.String("addr", a.srv.Addr()))</span>
}

func (a *App) GracefulStop(ctx context.Context) <span class="cov0" title="0">{
        a.srv.GracefulStop(ctx)
        a.db.Close()
        a.rdb.Close()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "flag"
        "fmt"
        "os"
        "time"

        "github.com/ilyakaznacheev/cleanenv"
)

type Config struct {
        Env    string       `yaml:"env" env-default:"prod"`
        Server ServerConfig `yaml:"server"`
        DB     DBConfig     `yaml:"db"`
        Redis  RedisConfig  `yaml:"redis"`
        Minio  MinioConfig  `yaml:"minio"`
        Mail   MailConfig   `yaml:"mail"`
}

type ServerConfig struct {
        Addr        string        `yaml:"addr" env-default:"0.0.0.0:50070"`
        Timeout     time.Duration `yaml:"timeout" env-default:"4s"`
        IdleTimeout time.Duration `yaml:"idle_timeout" env-default:"60s"`
}

type DBConfig struct {
        Host           string `env:"DB_HOST" yaml:"host" env-default:"localhost"`
        Port           int    `env:"DB_PORT" yaml:"port" env-default:"5222"`
        User           string `env:"DB_USER" yaml:"user" env-default:"postgres"`
        Password       string `env:"DB_PASSWORD" yaml:"password" env-required:"true"`
        Name           string `env:"DB_NAME" yaml:"name" env-default:"chat"`
        MinPools       int    `env:"DB_MIN_POOLS" yaml:"min_pools" env-default:"3"`
        MaxPools       int    `env:"DB_MAX_POOLS" yaml:"max_pools" env-default:"5"`
        MigrationsPath string `env:"MIGRATIONS_PATH" yaml:"migrations_path" env-default:"./migrations"`
}

type RedisConfig struct {
        Host       string        `env:"REDIS_HOST" yaml:"host" env-default:"localhost"`
        Port       int           `env:"REDIS_PORT" yaml:"port" env-default:"6379"`
        User       string        `env:"REDIS_USER" yaml:"user" env-default:"root"`
        Password   string        `env:"REDIS_PASSWORD" yaml:"password" env-default:"root"`
        DB         int           `env:"REDIS_DB" yaml:"db" env-default:"0"`
        Expiration time.Duration `env:"REDIS_EXPIRATION" yaml:"expire_time" env-default:"24h"`
}

type MinioConfig struct {
        Endpoint   string `env:"MINIO_ENDPOINT" yaml:"endpoint" env-default:"localhost:9000"`
        Port       int    `env:"MINIO_PORT" yaml:"port" env-default:"9000"`
        User       string `env:"MINIO_ROOT_USER" yaml:"user" env-default:"minio"`
        Password   string `env:"MINIO_ROOT_PASSWORD" yaml:"password" env-required:"true"`
        BucketName string `env:"MINIO_BUCKET_NAME" yaml:"bucket_name" env-default:"users"`
        IsUseSsl   bool   `env:"MINIO_USE_SSL" yaml:"is_use_ssl" env-default:"false"`
}

type MailConfig struct {
        Host     string `env:"MAIL_HOST" yaml:"host" env-required:"true"`
        Port     int    `env:"MAIL_PORT" yaml:"port" env-required:"true"`
        FromAddr string `env:"MAIL_FROM_ADDR" yaml:"from_addr" env-required:"true"`
        Password string `env:"MAIL_PASSWORD" yaml:"password" env-required:"true"`
}

func MustLoad() *Config <span class="cov0" title="0">{
        path := fetchPath()
        cfg, err := Load(path)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return cfg</span>
}

func Load(path string) (*Config, error) <span class="cov0" title="0">{
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config file does not exist: %s", path)
        }</span>

        <span class="cov0" title="0">cfg := &amp;Config{}

        if err := cleanenv.ReadConfig(path, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}

func fetchPath() string <span class="cov0" title="0">{
        var path string

        flag.StringVar(&amp;path, "config", "", "path to config file")
        flag.Parse()

        if path == "" </span><span class="cov0" title="0">{
                path = os.Getenv("CONFIG_PATH")
        }</span>

        <span class="cov0" title="0">return path</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package email

import (
        "bytes"
        "fmt"
        "html/template"
        "net/smtp"

        "github.com/AlexMickh/coledzh-shop-backend/internal/config"
)

type VerificationEmailVars struct {
        Login string
        Token string
}

type Email struct {
        cfg  config.MailConfig
        auth smtp.Auth
}

func New(cfg config.MailConfig) *Email <span class="cov0" title="0">{
        return &amp;Email{
                cfg:  cfg,
                auth: smtp.PlainAuth("", cfg.FromAddr, cfg.Password, cfg.Host),
        }
}</span>

func (e *Email) SendVerification(to string, token, login string) error <span class="cov0" title="0">{
        const op = "lib.email.Send"

        tmpl, err := template.ParseFiles("./internal/lib/email/templates/verify-email.html")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">rendered := new(bytes.Buffer)
        vars := VerificationEmailVars{
                Login: login,
                Token: token,
        }
        if err = tmpl.Execute(rendered, vars); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">headers := "MIME-version: 1.0;\nContent-Type: text/html; charset=\"UTF-8\";"

        err = smtp.SendMail(
                fmt.Sprintf("%s:%d", e.cfg.Host, e.cfg.Port),
                e.auth,
                e.cfg.FromAddr,
                []string{to},
                fmt.Appendf(nil, "Subject: Email\n%s\n\n%s", headers, rendered.String()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package token_repository

import (
        "context"
        "fmt"

        "github.com/jackc/pgx/v5/pgxpool"
)

type Postgres struct {
        db *pgxpool.Pool
}

func New(db *pgxpool.Pool) *Postgres <span class="cov0" title="0">{
        return &amp;Postgres{
                db: db,
        }
}</span>

func (p *Postgres) SaveToken(ctx context.Context, userId, token, tokenType string) error <span class="cov8" title="1">{
        const op = "repository.postgres.token.SaveToken"

        query := `INSERT INTO tokens
                          (user_id, token, type)
                          VALUES ($1, $2, $3)`
        _, err := p.db.Exec(ctx, query, userId, token, tokenType)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package user_repository

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/AlexMickh/coledzh-shop-backend/internal/errs"
        "github.com/AlexMickh/coledzh-shop-backend/internal/models"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"
)

type Postgres struct {
        db *pgxpool.Pool
}

func New(db *pgxpool.Pool) *Postgres <span class="cov0" title="0">{
        return &amp;Postgres{
                db: db,
        }
}</span>

func (p *Postgres) SaveUser(ctx context.Context, login, email, password string) (string, error) <span class="cov8" title="1">{
        const op = "repository.postgres.user.SaveUser"

        query := `INSERT INTO users 
                          (login, email, password)
                          VALUES ($1, $2, $3)
                          RETURNING id`
        var id string
        err := p.db.QueryRow(ctx, query, login, email, password).Scan(&amp;id)
        if err != nil </span><span class="cov8" title="1">{
                var pgErr *pgconn.PgError
                if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                        if pgErr.Code == "23505" </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("%s: %w", op, errs.ErrUserAlreadyExists)
                        }</span>
                }
                <span class="cov0" title="0">return "", fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return id, nil</span>
}

func (p *Postgres) SaveAdmin(ctx context.Context, login, email, password string) error <span class="cov8" title="1">{
        const op = "repository.postgres.user.SaveAdmin"

        query := `INSERT INTO users 
                          (login, email, password, role, is_email_verified)
                          VALUES ($1, $2, $3, $4, $5)`
        _, err := p.db.Exec(ctx, query, login, email, password, "admin", true)
        if err != nil </span><span class="cov8" title="1">{
                var pgErr *pgconn.PgError
                if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                        if pgErr.Code == "23505" </span><span class="cov8" title="1">{
                                return fmt.Errorf("%s: %w", op, errs.ErrUserAlreadyExists)
                        }</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (p *Postgres) UserByEmail(ctx context.Context, email string) (models.User, error) <span class="cov0" title="0">{
        const op = "repository.postgres.user.UserByEmail"

        query := "SELECT id, login, email, password, role, is_email_verified FROM users WHERE email = $1"
        var user models.User
        err := p.db.QueryRow(ctx, query, email).Scan(
                &amp;user.ID,
                &amp;user.Login,
                &amp;user.Email,
                &amp;user.Password,
                &amp;user.Role,
                &amp;user.IsEmailVerified,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.User{}, fmt.Errorf("%s: %w", op, errs.ErrUserNotFound)
                }</span>
                <span class="cov0" title="0">return models.User{}, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package session_cash

import (
        "context"
        "fmt"
        "time"

        "github.com/AlexMickh/coledzh-shop-backend/internal/models"
        "github.com/redis/go-redis/v9"
)

type Cash struct {
        rdb    *redis.Client
        expire time.Duration
}

func New(rdb *redis.Client, expire time.Duration) *Cash <span class="cov0" title="0">{
        return &amp;Cash{
                rdb:    rdb,
                expire: expire,
        }
}</span>

func (c *Cash) SaveSession(ctx context.Context, id string, user models.User) error <span class="cov8" title="1">{
        const op = "repository.redis.session.SaveSession"

        err := c.rdb.HSet(ctx, id, user).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">err = c.rdb.Expire(ctx, id, c.expire).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package login

import (
        "context"
        "errors"
        "log/slog"
        "net/http"

        "github.com/AlexMickh/coledzh-shop-backend/internal/errs"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/api"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/logger"
        "github.com/go-chi/render"
        "github.com/go-playground/validator/v10"
)

type Request struct {
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required,min=3"`
}

type Loginer interface {
        Login(ctx context.Context, email, password string) (string, error)
}

type SessionCreator interface {
        Create(w http.ResponseWriter, sessionId string)
}

func New(loginer Loginer, validator validator.Validate, sessionCreator SessionCreator) api.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) error </span><span class="cov0" title="0">{
                const op = "handlers.auth.login.New"
                ctx := r.Context()
                log := logger.FromCtx(ctx).With(slog.String("op", op))

                var req Request
                if err := render.DecodeJSON(r.Body, &amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to decode body", logger.Err(err))
                        return api.Error("failed to decode body", http.StatusBadRequest)
                }</span>
                <span class="cov0" title="0">defer r.Body.Close()

                if err := validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to validate request", logger.Err(err))
                        return api.Error("failed to validate request", http.StatusBadRequest)
                }</span>

                <span class="cov0" title="0">sessionId, err := loginer.Login(ctx, req.Email, req.Password)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, errs.ErrUserNotFound) </span><span class="cov0" title="0">{
                                log.Error("user not found", logger.Err(err))
                                return api.Error(errs.ErrUserNotFound.Error(), http.StatusNotFound)
                        }</span>

                        <span class="cov0" title="0">log.Error("failed to login user", logger.Err(err))
                        return api.Error("failed to login user", http.StatusInternalServerError)</span>
                }

                <span class="cov0" title="0">sessionCreator.Create(w, sessionId)

                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package register

import (
        "context"
        "errors"
        "log/slog"
        "net/http"

        "github.com/AlexMickh/coledzh-shop-backend/internal/consts"
        "github.com/AlexMickh/coledzh-shop-backend/internal/errs"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/api"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/logger"
        "github.com/go-chi/render"
        "github.com/go-playground/validator/v10"
)

type Request struct {
        Login    string `json:"login" validate:"required,min=3"`
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required,min=3"`
}

type Response struct {
        ID string `json:"id"`
}

type Registerer interface {
        Register(ctx context.Context, login, email, password string) (string, error)
}

type TokenCreator interface {
        CreateToken(ctx context.Context, userId, tokenType string) (string, error)
}

type VerificationSender interface {
        SendVerification(to string, token, login string) error
}

func New(
        validator *validator.Validate,
        registerer Registerer,
        tokenCreator TokenCreator,
        verificationSender VerificationSender,
) api.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) error </span><span class="cov8" title="1">{
                const op = "handlers.auth.register.New"
                ctx := r.Context()
                log := logger.FromCtx(ctx).With(slog.String("op", op))

                var req Request
                if err := render.DecodeJSON(r.Body, &amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to decode body", logger.Err(err))
                        return api.Error("failed to decode body", http.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">defer r.Body.Close()

                if err := validator.Struct(&amp;req); err != nil </span><span class="cov8" title="1">{
                        log.Error("failed to validate request", logger.Err(err))
                        return api.Error("failed to validate request", http.StatusBadRequest)
                }</span>

                <span class="cov8" title="1">id, err := registerer.Register(ctx, req.Login, req.Email, req.Password)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, errs.ErrUserAlreadyExists) </span><span class="cov0" title="0">{
                                log.Error("user already exists", logger.Err(err))
                                return api.Error(errs.ErrUserAlreadyExists.Error(), http.StatusBadRequest)
                        }</span>
                        <span class="cov0" title="0">log.Error("failed to register user", logger.Err(err))
                        return api.Error("failed to register user", http.StatusInternalServerError)</span>
                }

                <span class="cov8" title="1">token, err := tokenCreator.CreateToken(ctx, id, consts.TokenTypeEmailVerify)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to create token", logger.Err(err))
                        return api.Error("failed to create token", http.StatusInternalServerError)
                }</span>

                <span class="cov8" title="1">err = verificationSender.SendVerification(req.Email, token, req.Login)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to send email", logger.Err(err))
                        return api.Error("failed to send email", http.StatusInternalServerError)
                }</span>

                <span class="cov8" title="1">render.Status(r, http.StatusCreated)
                render.JSON(w, r, Response{
                        ID: id,
                })

                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package server

import (
        "context"
        "fmt"
        "net/http"

        "github.com/AlexMickh/coledzh-shop-backend/internal/config"
        "github.com/AlexMickh/coledzh-shop-backend/internal/lib/email"
        "github.com/AlexMickh/coledzh-shop-backend/internal/server/handlers/auth/register"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/api"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/logger"
        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "github.com/go-playground/validator/v10"
        "github.com/rs/cors"
)

type Server struct {
        srv *http.Server
}

type AuthService interface {
        Register(ctx context.Context, login, email, password string) (string, error)
}

type TokenService interface {
        CreateToken(ctx context.Context, userId, tokenType string) (string, error)
}

func New(
        ctx context.Context,
        cfg config.ServerConfig,
        authService AuthService,
        mailCfg config.MailConfig,
        tokenService TokenService,
) *Server <span class="cov0" title="0">{
        const op = "server.New"

        r := chi.NewRouter()

        validator := validator.New()
        email := email.New(mailCfg)

        r.Use(cors.New(cors.Options{
                AllowedOrigins:   []string{"*"},
                AllowCredentials: true,
        }).Handler)

        r.Use(middleware.RequestID)
        r.Use(logger.ChiMiddleware(ctx))
        r.Use(middleware.Recoverer)
        r.Use(middleware.URLFormat)

        r.Get("/health-check", api.ErrorWrapper(func(w http.ResponseWriter, r *http.Request) error </span><span class="cov0" title="0">{
                logger.FromCtx(r.Context()).Info("hello")
                w.WriteHeader(200)
                return nil
        }</span>))

        <span class="cov0" title="0">r.Route("/auth", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Post("/register", api.ErrorWrapper(register.New(validator, authService, tokenService, email)))
        }</span>)

        <span class="cov0" title="0">return &amp;Server{
                srv: &amp;http.Server{
                        Addr:         cfg.Addr,
                        Handler:      r,
                        ReadTimeout:  cfg.Timeout,
                        WriteTimeout: cfg.Timeout,
                        IdleTimeout:  cfg.IdleTimeout,
                },
        }</span>
}

func (s *Server) Run(ctx context.Context) error <span class="cov0" title="0">{
        const op = "server.Run"

        if err := s.srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Server) GracefulStop(ctx context.Context) error <span class="cov0" title="0">{
        const op = "server.GracefulStop"

        if err := s.srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Server) Addr() string <span class="cov0" title="0">{
        return s.srv.Addr
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package auth_service

import (
        "context"
        "fmt"

        "github.com/AlexMickh/coledzh-shop-backend/internal/errs"
        "github.com/AlexMickh/coledzh-shop-backend/internal/models"
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

type Storage interface {
        SaveUser(ctx context.Context, login, email, password string) (string, error)
        SaveAdmin(ctx context.Context, login, email, password string) error
        UserByEmail(ctx context.Context, email string) (models.User, error)
}

type SessionStore interface {
        SaveSession(ctx context.Context, id string, user models.User) error
}

type Service struct {
        storage      Storage
        sessionStore SessionStore
}

func New(storage Storage, sessionStore SessionStore) *Service <span class="cov0" title="0">{
        return &amp;Service{
                storage:      storage,
                sessionStore: sessionStore,
        }
}</span>

func (s *Service) Register(ctx context.Context, login, email, password string) (string, error) <span class="cov8" title="1">{
        const op = "services.auth.Register"

        hashPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">id, err := s.storage.SaveUser(ctx, login, email, string(hashPassword))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return id, nil</span>
}

func (s *Service) RegisterAdmin(ctx context.Context, login, email, password string) error <span class="cov8" title="1">{
        const op = "services.auth.Register"

        hashPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">err = s.storage.SaveAdmin(ctx, login, email, string(hashPassword))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *Service) Login(ctx context.Context, email, password string) (string, error) <span class="cov8" title="1">{
        const op = "services.auth.Login"

        user, err := s.storage.UserByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">if !user.IsEmailVerified </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", op, errs.ErrEmailNotVerify)
        }</span>

        <span class="cov8" title="1">err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", op, errs.ErrUserNotFound)
        }</span>

        <span class="cov8" title="1">sessionId := uuid.NewString()
        err = s.sessionStore.SaveSession(ctx, sessionId, user)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return sessionId, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package token_service

import (
        "context"
        "fmt"

        "github.com/AlexMickh/coledzh-shop-backend/internal/consts"
        "github.com/AlexMickh/coledzh-shop-backend/internal/errs"
        "github.com/google/uuid"
)

type Storage interface {
        SaveToken(ctx context.Context, userId, token, tokenType string) error
}

type Service struct {
        storage Storage
}

func New(storage Storage) *Service <span class="cov0" title="0">{
        return &amp;Service{
                storage: storage,
        }
}</span>

func (s *Service) CreateToken(ctx context.Context, userId, tokenType string) (string, error) <span class="cov8" title="1">{
        const op = "services.token.CreateToken"

        var token string
        switch tokenType </span>{
        case consts.TokenTypeEmailVerify:<span class="cov8" title="1">
                token = uuid.NewString()</span>
        default:<span class="cov8" title="1">
                return "", fmt.Errorf("%s: %w", op, errs.ErrWrongTokenType)</span>
        }

        <span class="cov8" title="1">err := s.storage.SaveToken(ctx, userId, token, tokenType)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package api

import (
        "net/http"

        "github.com/go-chi/render"
)

type HttpError struct {
        error
        msg    string
        status int
}

type ErrorResponse struct {
        Error string `json:"error"`
}

type HandlerFunc func(w http.ResponseWriter, r *http.Request) error

func ErrorWrapper(f func(w http.ResponseWriter, r *http.Request) error) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                err := f(w, r)
                if err != nil </span><span class="cov0" title="0">{
                        w.Header().Add("Content-Type", "application/json")
                        httpErr, ok := err.(HttpError)
                        if ok </span><span class="cov0" title="0">{
                                w.WriteHeader(httpErr.status)
                                render.JSON(w, r, ErrorResponse{Error: httpErr.msg})
                        }</span> else<span class="cov0" title="0"> {
                                w.WriteHeader(http.StatusInternalServerError)
                                render.JSON(w, r, ErrorResponse{Error: err.Error()})
                        }</span>
                }
        }
}

func Error(msg string, status int) HttpError <span class="cov0" title="0">{
        return HttpError{
                msg:    msg,
                status: status,
        }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package postgresql

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/AlexMickh/coledzh-shop-backend/pkg/utils/retry"
        "github.com/golang-migrate/migrate/v4"
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        "github.com/jackc/pgx/v5/pgxpool"
)

func New(
        ctx context.Context,
        username string,
        password string,
        host string,
        port int,
        database string,
        minPools int,
        maxPools int,
        migrationsPath string,
) (*pgxpool.Pool, error) <span class="cov0" title="0">{
        const op = "postgres-client.New"

        var pool *pgxpool.Pool

        err := retry.WithDelay(5, 500*time.Millisecond, func() error </span><span class="cov0" title="0">{
                var err error

                connString := fmt.Sprintf(
                        "postgres://%s:%s@%s:%d/%s?sslmode=disable&amp;pool_max_conns=%d&amp;pool_min_conns=%d",
                        username,
                        password,
                        host,
                        port,
                        database,
                        maxPools,
                        minPools,
                )

                pool, err = pgxpool.New(ctx, connString)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", op, err)
                }</span>

                <span class="cov0" title="0">err = pool.Ping(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", op, err)
                }</span>

                <span class="cov0" title="0">m, err := migrate.New(
                        "file://"+migrationsPath,
                        strings.Split(connString, "&amp;")[0],
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", op, err)
                }</span>

                <span class="cov0" title="0">if err = m.Up(); err != nil &amp;&amp; !errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", op, err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return pool, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package redis_client

import (
        "context"
        "fmt"
        "time"

        "github.com/AlexMickh/coledzh-shop-backend/pkg/utils/retry"
        "github.com/redis/go-redis/v9"
)

func New(
        ctx context.Context,
        addr string,
        user string,
        password string,
        db int,
) (*redis.Client, error) <span class="cov0" title="0">{
        const op = "redis-client.New"

        var rdb *redis.Client

        err := retry.WithDelay(5, 500*time.Millisecond, func() error </span><span class="cov0" title="0">{
                rdb = redis.NewClient(&amp;redis.Options{
                        Addr:     addr,
                        Password: password,
                        DB:       db,
                })

                err := rdb.Ping(ctx).Err()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", op, err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return rdb, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package logger

import (
        "context"
        "io"
        "log/slog"
        "net/http"
        "time"

        "github.com/go-chi/chi/v5/middleware"
)

type key string

var (
        Key       = key("logger")
        RequestID = "request_id"
)

func New(env string, w io.Writer) *slog.Logger <span class="cov0" title="0">{
        var log *slog.Logger

        switch env </span>{
        case "local":<span class="cov0" title="0">
                log = slog.New(
                        slog.NewTextHandler(w, &amp;slog.HandlerOptions{Level: slog.LevelDebug}),
                )</span>
        case "dev":<span class="cov0" title="0">
                log = slog.New(
                        slog.NewJSONHandler(w, &amp;slog.HandlerOptions{Level: slog.LevelDebug}),
                )</span>
        case "prod":<span class="cov0" title="0">
                log = slog.New(
                        slog.NewJSONHandler(w, &amp;slog.HandlerOptions{Level: slog.LevelInfo}),
                )</span>
        default:<span class="cov0" title="0">
                log = slog.Default()</span>
        }

        <span class="cov0" title="0">return log</span>
}

func Err(err error) slog.Attr <span class="cov0" title="0">{
        return slog.Attr{
                Key:   "error",
                Value: slog.StringValue(err.Error()),
        }
}</span>

func ContextWithLogger(ctx context.Context, log *slog.Logger) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, Key, log)
}</span>

func FromCtx(ctx context.Context) *slog.Logger <span class="cov0" title="0">{
        log, ok := ctx.Value(Key).(*slog.Logger)
        if !ok </span><span class="cov0" title="0">{
                return slog.Default()
        }</span>

        <span class="cov0" title="0">return log</span>
}

func ChiMiddleware(ctx context.Context) func(next http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                log := FromCtx(ctx)

                log.Info("logger middleware enabled")

                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        guid := middleware.GetReqID(r.Context())
                        ctx = context.WithValue(r.Context(), RequestID, guid)
                        log = log.With(slog.String("request_id", guid))
                        log.Info(
                                "new request",
                                slog.String("method", r.Method),
                                slog.String("path", r.URL.Path),
                                slog.String("remove_addr", r.RemoteAddr),
                                slog.String("user_agent", r.UserAgent()),
                        )
                        ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)

                        t1 := time.Now()
                        defer func() </span><span class="cov0" title="0">{
                                FromCtx(ctx).Info("request completed",
                                        slog.Int("status", ww.Status()),
                                        slog.Int("bytes", ww.BytesWritten()),
                                        slog.String("duration", time.Since(t1).String()),
                                )
                        }</span>()

                        <span class="cov0" title="0">ctx = context.WithValue(ctx, Key, log)
                        r = r.WithContext(ctx)

                        next.ServeHTTP(ww, r)</span>
                }

                <span class="cov0" title="0">return http.HandlerFunc(fn)</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package session

import "net/http"

func Create(w http.ResponseWriter, sessionId string) <span class="cov0" title="0">{
        cookie := &amp;http.Cookie{
                Name:     "session_id",
                Value:    sessionId,
                Path:     "/",
                HttpOnly: true,
                Secure:   false,
                SameSite: http.SameSiteStrictMode,
                MaxAge:   60 * 60 * 24 * 5,
        }
        http.SetCookie(w, cookie)
        w.WriteHeader(http.StatusCreated)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package retry

import "time"

func WithDelay(maxAttempts int, delay time.Duration, fn func() error) error <span class="cov0" title="0">{
        var err error

        for maxAttempts &gt; 0 </span><span class="cov0" title="0">{
                if err = fn(); err != nil </span><span class="cov0" title="0">{
                        time.Sleep(delay)
                        maxAttempts--
                        continue</span>
                }

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>


<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/AlexMickh/coledzh-shop-backend/cmd/app/main.go (0.0%)</option>
				
				<option value="file1">github.com/AlexMickh/coledzh-shop-backend/cmd/create-admin/main.go (0.0%)</option>
				
				<option value="file2">github.com/AlexMickh/coledzh-shop-backend/cmd/env-setter/main.go (0.0%)</option>
				
				<option value="file3">github.com/AlexMickh/coledzh-shop-backend/cmd/migrator/main.go (0.0%)</option>
				
				<option value="file4">github.com/AlexMickh/coledzh-shop-backend/docs/docs.go (0.0%)</option>
				
				<option value="file5">github.com/AlexMickh/coledzh-shop-backend/internal/app/app.go (0.0%)</option>
				
				<option value="file6">github.com/AlexMickh/coledzh-shop-backend/internal/config/config.go (0.0%)</option>
				
				<option value="file7">github.com/AlexMickh/coledzh-shop-backend/internal/lib/email/email.go (0.0%)</option>
				
				<option value="file8">github.com/AlexMickh/coledzh-shop-backend/internal/repository/postgres/category/category.go (81.5%)</option>
				
				<option value="file9">github.com/AlexMickh/coledzh-shop-backend/internal/repository/postgres/token/token.go (31.2%)</option>
				
				<option value="file10">github.com/AlexMickh/coledzh-shop-backend/internal/repository/postgres/user/user.go (51.4%)</option>
				
				<option value="file11">github.com/AlexMickh/coledzh-shop-backend/internal/repository/redis/category/category.go (80.8%)</option>
				
				<option value="file12">github.com/AlexMickh/coledzh-shop-backend/internal/repository/redis/session/session.go (40.0%)</option>
				
				<option value="file13">github.com/AlexMickh/coledzh-shop-backend/internal/server/handlers/auth/login/login.go (0.0%)</option>
				
				<option value="file14">github.com/AlexMickh/coledzh-shop-backend/internal/server/handlers/auth/register/register.go (63.3%)</option>
				
				<option value="file15">github.com/AlexMickh/coledzh-shop-backend/internal/server/handlers/auth/verify/verify.go (0.0%)</option>
				
				<option value="file16">github.com/AlexMickh/coledzh-shop-backend/internal/server/handlers/category/create/create.go (0.0%)</option>
				
				<option value="file17">github.com/AlexMickh/coledzh-shop-backend/internal/server/handlers/category/get/get.go (0.0%)</option>
				
				<option value="file18">github.com/AlexMickh/coledzh-shop-backend/internal/server/middlewares/middlewares.go (0.0%)</option>
				
				<option value="file19">github.com/AlexMickh/coledzh-shop-backend/internal/server/server.go (0.0%)</option>
				
				<option value="file20">github.com/AlexMickh/coledzh-shop-backend/internal/services/auth/auth.go (61.1%)</option>
				
				<option value="file21">github.com/AlexMickh/coledzh-shop-backend/internal/services/category/category.go (26.9%)</option>
				
				<option value="file22">github.com/AlexMickh/coledzh-shop-backend/internal/services/token/token.go (44.4%)</option>
				
				<option value="file23">github.com/AlexMickh/coledzh-shop-backend/internal/services/user/user.go (0.0%)</option>
				
				<option value="file24">github.com/AlexMickh/coledzh-shop-backend/pkg/api/api.go (0.0%)</option>
				
				<option value="file25">github.com/AlexMickh/coledzh-shop-backend/pkg/clients/postgresql/postgresql.go (0.0%)</option>
				
				<option value="file26">github.com/AlexMickh/coledzh-shop-backend/pkg/clients/redis/redis.go (0.0%)</option>
				
				<option value="file27">github.com/AlexMickh/coledzh-shop-backend/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file28">github.com/AlexMickh/coledzh-shop-backend/pkg/session/session.go (0.0%)</option>
				
				<option value="file29">github.com/AlexMickh/coledzh-shop-backend/pkg/utils/retry/retry.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "io"
        "log/slog"
        "os"
        "os/signal"
        "syscall"

        "github.com/AlexMickh/coledzh-shop-backend/internal/app"
        "github.com/AlexMickh/coledzh-shop-backend/internal/config"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/logger"
)

func main() <span class="cov0" title="0">{
        cfg := config.MustLoad()

        file, err := os.OpenFile(cfg.Env+".log", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0666)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer file.Close()

        log := logger.New(cfg.Env, io.MultiWriter(os.Stdout, file))

        log.Info("logger is working", slog.String("env", cfg.Env))

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()
        ctx = logger.ContextWithLogger(ctx, log)

        app := app.New(ctx, cfg)
        app.Run(ctx)
        defer app.GracefulStop(ctx)

        stop := make(chan os.Signal, 1)
        signal.Notify(stop, syscall.SIGTERM, syscall.SIGINT)

        &lt;-stop

        close(stop)
        logger.FromCtx(ctx).Info("server stopped")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"

        "github.com/AlexMickh/coledzh-shop-backend/internal/config"
        user_repository "github.com/AlexMickh/coledzh-shop-backend/internal/repository/postgres/user"
        session_cash "github.com/AlexMickh/coledzh-shop-backend/internal/repository/redis/session"
        auth_service "github.com/AlexMickh/coledzh-shop-backend/internal/services/auth"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/clients/postgresql"
        redis_client "github.com/AlexMickh/coledzh-shop-backend/pkg/clients/redis"
)

func main() <span class="cov0" title="0">{
        var (
                login    string
                email    string
                password string
        )

        fmt.Print("Input login: ")
        fmt.Scan(&amp;login)
        fmt.Print("Input email: ")
        fmt.Scan(&amp;email)
        fmt.Print("Input password: ")
        fmt.Scan(&amp;password)

        cfg := config.MustLoad()

        db, err := postgresql.New(
                context.Background(),
                cfg.DB.User,
                cfg.DB.Password,
                cfg.DB.Host,
                cfg.DB.Port,
                cfg.DB.Name,
                cfg.DB.MinPools,
                cfg.DB.MaxPools,
                cfg.DB.MigrationsPath,
        )
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer db.Close()
        userRepository := user_repository.New(db)

        cash, err := redis_client.New(
                context.Background(),
                fmt.Sprintf("%s:%d", cfg.Redis.Host, cfg.Redis.Port),
                cfg.Redis.User,
                cfg.Redis.Password,
                cfg.Redis.DB,
        )
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">sessionCash := session_cash.New(cash, cfg.Redis.Expiration)

        authService := auth_service.New(userRepository, sessionCash)

        err = authService.RegisterAdmin(context.Background(), login, email, password)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">fmt.Printf("admin with login %s successfully created", login)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
        "io"
        "os"
        "reflect"

        "github.com/AlexMickh/coledzh-shop-backend/internal/config"
)

func main() <span class="cov0" title="0">{
        cfg := config.MustLoad()

        file, err := os.Create(".env")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = file.Close()
        }</span>()

        <span class="cov0" title="0">v := reflect.ValueOf(*cfg)

        processStruct(file, v)</span>
}

func processStruct(w io.Writer, v reflect.Value) <span class="cov0" title="0">{
        t := v.Type()

        for i := range v.NumField() </span><span class="cov0" title="0">{
                field := v.Field(i)

                if field.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                        processStruct(w, field)
                }</span> else<span class="cov0" title="0"> {
                        fieldValue := v.Field(i)
                        fieldType := t.Field(i)
                        tag := fieldType.Tag.Get("env")
                        if tag == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">_, err := fmt.Fprintf(w, "%s=%s\n", tag, fmt.Sprint(fieldValue))
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "errors"
        "fmt"
        "log"
        "os"

        "github.com/golang-migrate/migrate/v4"
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
)

func main() <span class="cov0" title="0">{
        username := os.Getenv("DB_USER")
        if username == "" </span><span class="cov0" title="0">{
                log.Fatal("DB_USER is required")
        }</span>
        <span class="cov0" title="0">password := os.Getenv("DB_PASSWORD")
        if password == "" </span><span class="cov0" title="0">{
                log.Fatal("DB_PASSWORD is required")
        }</span>
        <span class="cov0" title="0">host := os.Getenv("DB_HOST")
        if host == "" </span><span class="cov0" title="0">{
                log.Fatal("DB_HOST is required")
        }</span>
        <span class="cov0" title="0">port := os.Getenv("DB_PORT")
        if port == "" </span><span class="cov0" title="0">{
                log.Fatal("DB_PORT is required")
        }</span>
        <span class="cov0" title="0">database := os.Getenv("DB_NAME")
        if database == "" </span><span class="cov0" title="0">{
                log.Fatal("DB_NAME is required")
        }</span>
        <span class="cov0" title="0">migrationsPath := os.Getenv("MIGRATIONS_PATH")
        if database == "" </span><span class="cov0" title="0">{
                log.Fatal("MIGRATIONS_PATH is required")
        }</span>

        <span class="cov0" title="0">m, err := migrate.New(
                "file://"+migrationsPath,
                fmt.Sprintf(
                        "postgres://%s:%s@%s:%s/%s?sslmode=disable",
                        username,
                        password,
                        host,
                        port,
                        database,
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">if err := m.Up(); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                        log.Println("no migrations to apply")
                        return
                }</span>
                <span class="cov0" title="0">log.Fatal(err)</span>
        }

        <span class="cov0" title="0">log.Println("migrations applied")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/admin/create-category": {
            "post": {
                "security": [
                    {
                        "SessionAuth": []
                    }
                ],
                "description": "create new category",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "admin"
                ],
                "summary": "create new category",
                "parameters": [
                    {
                        "description": "category name",
                        "name": "name",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/create_category.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/login": {
            "post": {
                "description": "login user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "login user",
                "parameters": [
                    {
                        "format": "email",
                        "description": "User email",
                        "name": "email",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "string"
                        }
                    },
                    {
                        "description": "User password",
                        "name": "password",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "register user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "register user",
                "parameters": [
                    {
                        "description": "User login",
                        "name": "login",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "string"
                        }
                    },
                    {
                        "format": "email",
                        "description": "User email",
                        "name": "email",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "string"
                        }
                    },
                    {
                        "description": "User password",
                        "name": "password",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/register.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/verify/{token}": {
            "get": {
                "description": "verify user email",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "verify user email",
                "parameters": [
                    {
                        "type": "string",
                        "description": "token",
                        "name": "token",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/category": {
            "get": {
                "description": "returns all categories",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "category"
                ],
                "summary": "returns all categories",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/get_category.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/api.ErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "api.ErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                }
            }
        },
        "create_category.Response": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                }
            }
        },
        "get_category.Response": {
            "type": "object",
            "properties": {
                "categories": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/get_category.category"
                    }
                }
            }
        },
        "get_category.category": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "register.Response": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "SessionAuth": {
            "type": "apiKey",
            "name": "session_id",
            "in": "cookie"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "Your API",
        Description:      "Your API description",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"
        "os"

        "github.com/AlexMickh/coledzh-shop-backend/internal/config"
        category_repository "github.com/AlexMickh/coledzh-shop-backend/internal/repository/postgres/category"
        token_repository "github.com/AlexMickh/coledzh-shop-backend/internal/repository/postgres/token"
        user_repository "github.com/AlexMickh/coledzh-shop-backend/internal/repository/postgres/user"
        category_cash "github.com/AlexMickh/coledzh-shop-backend/internal/repository/redis/category"
        session_cash "github.com/AlexMickh/coledzh-shop-backend/internal/repository/redis/session"
        "github.com/AlexMickh/coledzh-shop-backend/internal/server"
        auth_service "github.com/AlexMickh/coledzh-shop-backend/internal/services/auth"
        category_service "github.com/AlexMickh/coledzh-shop-backend/internal/services/category"
        token_service "github.com/AlexMickh/coledzh-shop-backend/internal/services/token"
        user_service "github.com/AlexMickh/coledzh-shop-backend/internal/services/user"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/clients/postgresql"
        redis_client "github.com/AlexMickh/coledzh-shop-backend/pkg/clients/redis"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/logger"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/redis/go-redis/v9"
)

type App struct {
        srv *server.Server
        db  *pgxpool.Pool
        rdb *redis.Client
}

func New(ctx context.Context, cfg *config.Config) *App <span class="cov0" title="0">{
        const op = "app.New"

        log := logger.FromCtx(ctx).With(slog.String("op", op))

        log.Info("initing postgres")
        db, err := postgresql.New(
                ctx,
                cfg.DB.User,
                cfg.DB.Password,
                cfg.DB.Host,
                cfg.DB.Port,
                cfg.DB.Name,
                cfg.DB.MinPools,
                cfg.DB.MaxPools,
                cfg.DB.MigrationsPath,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to init postgres", logger.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">userRepository := user_repository.New(db)
        tokenRepository := token_repository.New(db)
        categoryRepository := category_repository.New(db)

        log.Info("initing redis")
        cash, err := redis_client.New(
                ctx,
                fmt.Sprintf("%s:%d", cfg.Redis.Host, cfg.Redis.Port),
                cfg.Redis.User,
                cfg.Redis.Password,
                cfg.Redis.DB,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to init redis", logger.Err(err))
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">sessionCash := session_cash.New(cash, cfg.Redis.Expiration)
        categoryCash := category_cash.New(cash, cfg.Redis.Expiration)

        log.Info("initing service layer")
        authService := auth_service.New(userRepository, sessionCash)
        tokenService := token_service.New(tokenRepository, authService)
        categoryService := category_service.New(categoryRepository, categoryCash)
        userService := user_service.New(sessionCash)

        log.Info("initing server")
        srv := server.New(
                ctx,
                cfg.Server,
                authService,
                cfg.Mail,
                tokenService,
                categoryService,
                userService,
        )

        return &amp;App{
                srv: srv,
                db:  db,
                rdb: cash,
        }</span>
}

func (a *App) Run(ctx context.Context) <span class="cov0" title="0">{
        const op = "app.Run"

        log := logger.FromCtx(ctx).With(slog.String("op", op))

        go func() </span><span class="cov0" title="0">{
                if err := a.srv.Run(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to start server", logger.Err(err))
                        os.Exit(1)
                }</span>
        }()

        <span class="cov0" title="0">log.Info("server started", slog.String("addr", a.srv.Addr()))</span>
}

func (a *App) GracefulStop(ctx context.Context) <span class="cov0" title="0">{
        a.srv.GracefulStop(ctx)
        a.db.Close()
        a.rdb.Close()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "flag"
        "fmt"
        "os"
        "time"

        "github.com/ilyakaznacheev/cleanenv"
)

type Config struct {
        Env    string       `yaml:"env" env-default:"prod"`
        Server ServerConfig `yaml:"server"`
        DB     DBConfig     `yaml:"db"`
        Redis  RedisConfig  `yaml:"redis"`
        Minio  MinioConfig  `yaml:"minio"`
        Mail   MailConfig   `yaml:"mail"`
}

type ServerConfig struct {
        Addr        string        `yaml:"addr" env-default:"0.0.0.0:50070"`
        Timeout     time.Duration `yaml:"timeout" env-default:"4s"`
        IdleTimeout time.Duration `yaml:"idle_timeout" env-default:"60s"`
}

type DBConfig struct {
        Host           string `env:"DB_HOST" yaml:"host" env-default:"localhost"`
        Port           int    `env:"DB_PORT" yaml:"port" env-default:"5222"`
        User           string `env:"DB_USER" yaml:"user" env-default:"postgres"`
        Password       string `env:"DB_PASSWORD" yaml:"password" env-required:"true"`
        Name           string `env:"DB_NAME" yaml:"name" env-default:"chat"`
        MinPools       int    `env:"DB_MIN_POOLS" yaml:"min_pools" env-default:"3"`
        MaxPools       int    `env:"DB_MAX_POOLS" yaml:"max_pools" env-default:"5"`
        MigrationsPath string `env:"MIGRATIONS_PATH" yaml:"migrations_path" env-default:"./migrations"`
}

type RedisConfig struct {
        Host       string        `env:"REDIS_HOST" yaml:"host" env-default:"localhost"`
        Port       int           `env:"REDIS_PORT" yaml:"port" env-default:"6379"`
        User       string        `env:"REDIS_USER" yaml:"user" env-default:"root"`
        Password   string        `env:"REDIS_PASSWORD" yaml:"password" env-default:"root"`
        DB         int           `env:"REDIS_DB" yaml:"db" env-default:"0"`
        Expiration time.Duration `env:"REDIS_EXPIRATION" yaml:"expire_time" env-default:"24h"`
}

type MinioConfig struct {
        Endpoint   string `env:"MINIO_ENDPOINT" yaml:"endpoint" env-default:"localhost:9000"`
        Port       int    `env:"MINIO_PORT" yaml:"port" env-default:"9000"`
        User       string `env:"MINIO_ROOT_USER" yaml:"user" env-default:"minio"`
        Password   string `env:"MINIO_ROOT_PASSWORD" yaml:"password" env-required:"true"`
        BucketName string `env:"MINIO_BUCKET_NAME" yaml:"bucket_name" env-default:"users"`
        IsUseSsl   bool   `env:"MINIO_USE_SSL" yaml:"is_use_ssl" env-default:"false"`
}

type MailConfig struct {
        Host     string `env:"MAIL_HOST" yaml:"host" env-required:"true"`
        Port     int    `env:"MAIL_PORT" yaml:"port" env-required:"true"`
        FromAddr string `env:"MAIL_FROM_ADDR" yaml:"from_addr" env-required:"true"`
        Password string `env:"MAIL_PASSWORD" yaml:"password" env-required:"true"`
}

func MustLoad() *Config <span class="cov0" title="0">{
        path := fetchPath()
        cfg, err := Load(path)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return cfg</span>
}

func Load(path string) (*Config, error) <span class="cov0" title="0">{
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config file does not exist: %s", path)
        }</span>

        <span class="cov0" title="0">cfg := &amp;Config{}

        if err := cleanenv.ReadConfig(path, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}

func fetchPath() string <span class="cov0" title="0">{
        var path string

        flag.StringVar(&amp;path, "config", "", "path to config file")
        flag.Parse()

        if path == "" </span><span class="cov0" title="0">{
                path = os.Getenv("CONFIG_PATH")
        }</span>

        <span class="cov0" title="0">return path</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package email

import (
        "bytes"
        "fmt"
        "html/template"
        "net/smtp"

        "github.com/AlexMickh/coledzh-shop-backend/internal/config"
)

type VerificationEmailVars struct {
        Login string
        Token string
}

type Email struct {
        cfg  config.MailConfig
        auth smtp.Auth
}

func New(cfg config.MailConfig) *Email <span class="cov0" title="0">{
        return &amp;Email{
                cfg:  cfg,
                auth: smtp.PlainAuth("", cfg.FromAddr, cfg.Password, cfg.Host),
        }
}</span>

func (e *Email) SendVerification(to string, token, login string) error <span class="cov0" title="0">{
        const op = "lib.email.Send"

        tmpl, err := template.ParseFiles("./internal/lib/email/templates/verify-email.html")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">rendered := new(bytes.Buffer)
        vars := VerificationEmailVars{
                Login: login,
                Token: token,
        }
        if err = tmpl.Execute(rendered, vars); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">headers := "MIME-version: 1.0;\nContent-Type: text/html; charset=\"UTF-8\";"

        err = smtp.SendMail(
                fmt.Sprintf("%s:%d", e.cfg.Host, e.cfg.Port),
                e.auth,
                e.cfg.FromAddr,
                []string{to},
                fmt.Appendf(nil, "Subject: Email\n%s\n\n%s", headers, rendered.String()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package category_repository

import (
        "context"
        "errors"
        "fmt"

        "github.com/AlexMickh/coledzh-shop-backend/internal/errs"
        "github.com/AlexMickh/coledzh-shop-backend/internal/models"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"
)

type Postgres struct {
        db *pgxpool.Pool
}

func New(db *pgxpool.Pool) *Postgres <span class="cov0" title="0">{
        return &amp;Postgres{
                db: db,
        }
}</span>

func (p *Postgres) SaveCategory(ctx context.Context, id string, name string) error <span class="cov8" title="1">{
        const op = "repository.postgres.category.SaveCategory"

        query := "INSERT INTO categories (id, name) VALUES ($1, $2)"
        _, err := p.db.Exec(ctx, query, id, name)
        if err != nil </span><span class="cov8" title="1">{
                var pgErr *pgconn.PgError
                if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                        if pgErr.Code == "23505" </span><span class="cov8" title="1">{
                                return fmt.Errorf("%s: %w", op, errs.ErrCategoryAlreadyExists)
                        }</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (p *Postgres) AllCategories(ctx context.Context) ([]models.Category, error) <span class="cov8" title="1">{
        const op = "repository.postgres.category.AllCategories"

        query := "SELECT id, name FROM categories"
        rows, err := p.db.Query(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        categories := make([]models.Category, 0)
        for rows.Next() </span><span class="cov8" title="1">{
                var category models.Category
                err := rows.Scan(&amp;category.ID, &amp;category.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">categories = append(categories, category)</span>
        }

        <span class="cov8" title="1">if rows.Err() != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return categories, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package token_repository

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/AlexMickh/coledzh-shop-backend/internal/errs"
        "github.com/jackc/pgx/v5/pgxpool"
)

type Postgres struct {
        db *pgxpool.Pool
}

func New(db *pgxpool.Pool) *Postgres <span class="cov0" title="0">{
        return &amp;Postgres{
                db: db,
        }
}</span>

func (p *Postgres) SaveToken(ctx context.Context, userId, token, tokenType string) error <span class="cov8" title="1">{
        const op = "repository.postgres.token.SaveToken"

        query := `INSERT INTO tokens
                          (user_id, token, type)
                          VALUES ($1, $2, $3)`
        _, err := p.db.Exec(ctx, query, userId, token, tokenType)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (p *Postgres) UserIdByToken(ctx context.Context, token, tokenType string) (string, error) <span class="cov0" title="0">{
        const op = "repository.postgres.token.UserIdByToken"

        query := "SELECT user_id FROM tokens WHERE token = $1 AND type = $2"
        var userId string
        err := p.db.QueryRow(ctx, query, token, tokenType).Scan(&amp;userId)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("%s: %w", op, errs.ErrTokenNotFound)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov0" title="0">return userId, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package user_repository

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/AlexMickh/coledzh-shop-backend/internal/consts"
        "github.com/AlexMickh/coledzh-shop-backend/internal/errs"
        "github.com/AlexMickh/coledzh-shop-backend/internal/models"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"
)

type Postgres struct {
        db *pgxpool.Pool
}

func New(db *pgxpool.Pool) *Postgres <span class="cov0" title="0">{
        return &amp;Postgres{
                db: db,
        }
}</span>

func (p *Postgres) SaveUser(ctx context.Context, login, email, password string) (string, error) <span class="cov8" title="1">{
        const op = "repository.postgres.user.SaveUser"

        query := `INSERT INTO users 
                          (login, email, password)
                          VALUES ($1, $2, $3)
                          RETURNING id`
        var id string
        err := p.db.QueryRow(ctx, query, login, email, password).Scan(&amp;id)
        if err != nil </span><span class="cov8" title="1">{
                var pgErr *pgconn.PgError
                if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                        if pgErr.Code == "23505" </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("%s: %w", op, errs.ErrUserAlreadyExists)
                        }</span>
                }
                <span class="cov0" title="0">return "", fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return id, nil</span>
}

func (p *Postgres) SaveAdmin(ctx context.Context, login, email, password string) error <span class="cov8" title="1">{
        const op = "repository.postgres.user.SaveAdmin"

        query := `INSERT INTO users 
                          (login, email, password, role, is_email_verified)
                          VALUES ($1, $2, $3, $4, $5)`
        _, err := p.db.Exec(ctx, query, login, email, password, consts.RoleAdmin, true)
        if err != nil </span><span class="cov8" title="1">{
                var pgErr *pgconn.PgError
                if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                        if pgErr.Code == "23505" </span><span class="cov8" title="1">{
                                return fmt.Errorf("%s: %w", op, errs.ErrUserAlreadyExists)
                        }</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (p *Postgres) UserByEmail(ctx context.Context, email string) (models.User, error) <span class="cov0" title="0">{
        const op = "repository.postgres.user.UserByEmail"

        query := "SELECT id, login, email, password, role, is_email_verified FROM users WHERE email = $1"
        var user models.User
        err := p.db.QueryRow(ctx, query, email).Scan(
                &amp;user.ID,
                &amp;user.Login,
                &amp;user.Email,
                &amp;user.Password,
                &amp;user.Role,
                &amp;user.IsEmailVerified,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.User{}, fmt.Errorf("%s: %w", op, errs.ErrUserNotFound)
                }</span>
                <span class="cov0" title="0">return models.User{}, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov0" title="0">return user, nil</span>
}

func (p *Postgres) VerifyEmail(ctx context.Context, id string) error <span class="cov0" title="0">{
        const op = "repository.postgres.user.VerifyEmail"

        query := "UPDATE users SET is_email_verified = $1 WHERE id = $2"
        _, err := p.db.Exec(ctx, query, true, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package category_cash

import (
        "context"
        "fmt"
        "time"

        "github.com/AlexMickh/coledzh-shop-backend/internal/models"
        "github.com/redis/go-redis/v9"
)

type Cash struct {
        rdb    *redis.Client
        expire time.Duration
}

func New(rdb *redis.Client, expire time.Duration) *Cash <span class="cov0" title="0">{
        return &amp;Cash{
                rdb:    rdb,
                expire: expire,
        }
}</span>

func (c *Cash) SaveCategory(ctx context.Context, categoty models.Category) error <span class="cov8" title="1">{
        const op = "repository.redis.category.SaveCategory"

        err := c.rdb.HSet(ctx, genKey(categoty.ID), categoty).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *Cash) AllCategories(ctx context.Context) ([]models.Category, error) <span class="cov8" title="1">{
        const op = "repository.redis.category.AllCategories"

        var (
                err    error
                cursor uint64
                keys   []string
        )
        for </span><span class="cov8" title="1">{
                keys, cursor, err = c.rdb.Scan(ctx, cursor, "category:*", 10).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">if cursor == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">if len(keys) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: nothing found", op)
        }</span>

        <span class="cov8" title="1">categories := make([]models.Category, 0, len(keys))
        for _, key := range keys </span><span class="cov8" title="1">{
                var category models.Category
                err = c.rdb.HGetAll(ctx, key).Scan(&amp;category)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", op, err)
                }</span>
                <span class="cov8" title="1">category.ID = key
                categories = append(categories, category)</span>
        }

        <span class="cov8" title="1">return categories, nil</span>
}

func genKey(id string) string <span class="cov8" title="1">{
        return "category:" + id
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package session_cash

import (
        "context"
        "fmt"
        "time"

        "github.com/AlexMickh/coledzh-shop-backend/internal/models"
        "github.com/redis/go-redis/v9"
)

type Cash struct {
        rdb    *redis.Client
        expire time.Duration
}

func New(rdb *redis.Client, expire time.Duration) *Cash <span class="cov0" title="0">{
        return &amp;Cash{
                rdb:    rdb,
                expire: expire,
        }
}</span>

func (c *Cash) SaveSession(ctx context.Context, id string, user models.User) error <span class="cov8" title="1">{
        const op = "repository.redis.session.SaveSession"

        err := c.rdb.HSet(ctx, id, user).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">err = c.rdb.Expire(ctx, id, c.expire).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *Cash) SessionById(ctx context.Context, sessionId string) (models.User, error) <span class="cov0" title="0">{
        const op = "repository.redis.session.SessionById"

        var user models.User
        err := c.rdb.HGetAll(ctx, sessionId).Scan(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                return models.User{}, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package login

import (
        "context"
        "errors"
        "log/slog"
        "net/http"

        "github.com/AlexMickh/coledzh-shop-backend/internal/errs"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/api"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/logger"
        "github.com/go-chi/render"
        "github.com/go-playground/validator/v10"
)

type Request struct {
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required,min=3"`
}

type Loginer interface {
        Login(ctx context.Context, email, password string) (string, error)
}

type SessionCreator interface {
        Create(w http.ResponseWriter, sessionId string)
}

// New godoc
//
//        @Summary                login user
//        @Description        login user
//        @Tags                        auth
//        @Accept                        json
//
//        @Produce                json
//
//        @Param                        email                body        string        true        "User email"        Format(email)
//        @Param                        password        body        string        true        "User password"
//        @Success                201
//        @Failure                400        {object}        api.ErrorResponse
//        @Failure                404        {object}        api.ErrorResponse
//        @Failure                500        {object}        api.ErrorResponse
//        @Router                        /auth/login [post]
func New(loginer Loginer, validator validator.Validate, sessionCreator SessionCreator) api.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) error </span><span class="cov0" title="0">{
                const op = "handlers.auth.login.New"
                ctx := r.Context()
                log := logger.FromCtx(ctx).With(slog.String("op", op))

                var req Request
                if err := render.DecodeJSON(r.Body, &amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to decode body", logger.Err(err))
                        return api.Error("failed to decode body", http.StatusBadRequest)
                }</span>
                <span class="cov0" title="0">defer r.Body.Close()

                if err := validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to validate request", logger.Err(err))
                        return api.Error("failed to validate request", http.StatusBadRequest)
                }</span>

                <span class="cov0" title="0">sessionId, err := loginer.Login(ctx, req.Email, req.Password)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, errs.ErrUserNotFound) </span><span class="cov0" title="0">{
                                log.Error("user not found", logger.Err(err))
                                return api.Error(errs.ErrUserNotFound.Error(), http.StatusNotFound)
                        }</span>

                        <span class="cov0" title="0">log.Error("failed to login user", logger.Err(err))
                        return api.Error("failed to login user", http.StatusInternalServerError)</span>
                }

                <span class="cov0" title="0">sessionCreator.Create(w, sessionId)

                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package register

import (
        "context"
        "errors"
        "log/slog"
        "net/http"

        "github.com/AlexMickh/coledzh-shop-backend/internal/consts"
        "github.com/AlexMickh/coledzh-shop-backend/internal/errs"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/api"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/logger"
        "github.com/go-chi/render"
        "github.com/go-playground/validator/v10"
)

type Request struct {
        Login    string `json:"login" validate:"required,min=3"`
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required,min=3"`
}

type Response struct {
        ID string `json:"id"`
}

type Registerer interface {
        Register(ctx context.Context, login, email, password string) (string, error)
}

type TokenCreator interface {
        CreateToken(ctx context.Context, userId, tokenType string) (string, error)
}

type VerificationSender interface {
        SendVerification(to string, token, login string) error
}

// New godoc
//
//        @Summary                register user
//        @Description        register user
//        @Tags                        auth
//        @Accept                        json
//
//        @Produce                json
//
//        @Param                        login                body                string        true        "User login"
//        @Param                        email                body                string        true        "User email"        Format(email)
//        @Param                        password        body                string        true        "User password"
//        @Success                201                        {object}        Response
//        @Failure                400                        {object}        api.ErrorResponse
//        @Failure                500                        {object}        api.ErrorResponse
//        @Router                        /auth/register [post]
func New(
        validator *validator.Validate,
        registerer Registerer,
        tokenCreator TokenCreator,
        verificationSender VerificationSender,
) api.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) error </span><span class="cov8" title="1">{
                const op = "handlers.auth.register.New"
                ctx := r.Context()
                log := logger.FromCtx(ctx).With(slog.String("op", op))

                var req Request
                if err := render.DecodeJSON(r.Body, &amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to decode body", logger.Err(err))
                        return api.Error("failed to decode body", http.StatusBadRequest)
                }</span>
                <span class="cov8" title="1">defer r.Body.Close()

                if err := validator.Struct(&amp;req); err != nil </span><span class="cov8" title="1">{
                        log.Error("failed to validate request", logger.Err(err))
                        return api.Error("failed to validate request", http.StatusBadRequest)
                }</span>

                <span class="cov8" title="1">id, err := registerer.Register(ctx, req.Login, req.Email, req.Password)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, errs.ErrUserAlreadyExists) </span><span class="cov0" title="0">{
                                log.Error("user already exists", logger.Err(err))
                                return api.Error(errs.ErrUserAlreadyExists.Error(), http.StatusBadRequest)
                        }</span>
                        <span class="cov0" title="0">log.Error("failed to register user", logger.Err(err))
                        return api.Error("failed to register user", http.StatusInternalServerError)</span>
                }

                <span class="cov8" title="1">token, err := tokenCreator.CreateToken(ctx, id, consts.TokenTypeEmailVerify)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to create token", logger.Err(err))
                        return api.Error("failed to create token", http.StatusInternalServerError)
                }</span>

                <span class="cov8" title="1">err = verificationSender.SendVerification(req.Email, token, req.Login)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to send email", logger.Err(err))
                        return api.Error("failed to send email", http.StatusInternalServerError)
                }</span>

                <span class="cov8" title="1">render.Status(r, http.StatusCreated)
                render.JSON(w, r, Response{
                        ID: id,
                })

                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package verify

import (
        "context"
        "errors"
        "log/slog"
        "net/http"

        "github.com/AlexMickh/coledzh-shop-backend/internal/errs"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/api"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/logger"
)

type TokenService interface {
        VerifyEmail(ctx context.Context, token string) error
}

// New godoc
//
//        @Summary                verify user email
//        @Description        verify user email
//        @Tags                        auth
//        @Accept                        json
//
//        @Produce                json
//
//        @Param                        token        path        string        true        "token"
//        @Success                204
//        @Failure                400        {object}        api.ErrorResponse
//        @Failure                404        {object}        api.ErrorResponse
//        @Failure                500        {object}        api.ErrorResponse
//        @Router                        /auth/verify/{token} [get]
func New(tokenService TokenService) api.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) error </span><span class="cov0" title="0">{
                const op = "handlers.auth.validate.New"
                ctx := r.Context()
                log := logger.FromCtx(ctx).With(slog.String("op", op))

                token := r.PathValue("token")
                if token == "" </span><span class="cov0" title="0">{
                        log.Error("token is empty")
                        return api.Error("token is empty", http.StatusBadRequest)
                }</span>

                <span class="cov0" title="0">err := tokenService.VerifyEmail(ctx, token)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, errs.ErrTokenNotFound) </span><span class="cov0" title="0">{
                                log.Error("token not found", logger.Err(err))
                                return api.Error(errs.ErrTokenNotFound.Error(), http.StatusNotFound)
                        }</span>
                        <span class="cov0" title="0">log.Error("failed to validate token", logger.Err(err))
                        return api.Error("failed to validate token", http.StatusInternalServerError)</span>
                }

                <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)

                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package create_category

import (
        "context"
        "errors"
        "log/slog"
        "net/http"

        "github.com/AlexMickh/coledzh-shop-backend/internal/errs"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/api"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/logger"
        "github.com/go-chi/render"
        "github.com/go-playground/validator/v10"
)

type Request struct {
        Name string `json:"name" validate:"required,min=3"`
}

type Response struct {
        ID string `json:"id"`
}

type CategoryCreator interface {
        CreateCategory(ctx context.Context, name string) (string, error)
}

// New godoc
//
//        @Summary                create new category
//        @Description        create new category
//        @Tags                        admin
//        @Accept                        json
//        @Produce                json
//        @Param                        name        body                string        true        "category name"
//        @Success                201                {object}        Response
//        @Failure                400                {object}        api.ErrorResponse
//        @Failure                500                {object}        api.ErrorResponse
//        @Security                SessionAuth
//        @Router                        /admin/create-category [post]
func New(categoryCreator CategoryCreator, validator *validator.Validate) api.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) error </span><span class="cov0" title="0">{
                const op = "handlers.category.create.New"
                ctx := r.Context()
                log := logger.FromCtx(ctx).With(slog.String("op", op))

                var req Request
                if err := render.DecodeJSON(r.Body, &amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to decode body", logger.Err(err))
                        return api.Error("failed to decode body", http.StatusBadRequest)
                }</span>
                <span class="cov0" title="0">defer r.Body.Close()

                if err := validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to validate request", logger.Err(err))
                        return api.Error("failed to validate request", http.StatusBadRequest)
                }</span>

                <span class="cov0" title="0">id, err := categoryCreator.CreateCategory(ctx, req.Name)
                if err != nil &amp;&amp; !errors.Is(err, errs.ErrFailedToCash) </span><span class="cov0" title="0">{
                        if errors.Is(err, errs.ErrCategoryAlreadyExists) </span><span class="cov0" title="0">{
                                log.Error("category already exists", logger.Err(err))
                                return api.Error(errs.ErrCategoryAlreadyExists.Error(), http.StatusBadRequest)
                        }</span>
                        <span class="cov0" title="0">log.Error("failed to create category", logger.Err(err))
                        return api.Error("failed to create category", http.StatusInternalServerError)</span>
                }

                <span class="cov0" title="0">render.Status(r, http.StatusCreated)
                render.JSON(w, r, Response{
                        ID: id,
                })

                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package get_category

import (
        "context"
        "log/slog"
        "net/http"

        "github.com/AlexMickh/coledzh-shop-backend/internal/models"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/api"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/logger"
        "github.com/go-chi/render"
)

type CategoryProvider interface {
        AllCategories(ctx context.Context) ([]models.Category, error)
}

type category struct {
        ID   string `json:"id"`
        Name string `json:"name"`
}

type Response struct {
        Categories []category `json:"categories"`
}

// New godoc
//
//        @Summary                returns all categories
//        @Description        returns all categories
//        @Tags                        category
//        @Accept                        json
//        @Produce                json
//        @Success                200        {object}        Response
//        @Failure                500        {object}        api.ErrorResponse
//        @Router                        /category [get]
func New(categoryProvider CategoryProvider) api.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) error </span><span class="cov0" title="0">{
                const op = "handlers.category.get.New"
                ctx := r.Context()
                log := logger.FromCtx(ctx).With(slog.String("op", op))

                categoriesInfo, err := categoryProvider.AllCategories(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to get all categories", logger.Err(err))
                        return api.Error("failed to get all categories", http.StatusInternalServerError)
                }</span>

                <span class="cov0" title="0">categories := make([]category, 0, len(categoriesInfo))
                for _, c := range categoriesInfo </span><span class="cov0" title="0">{
                        category := category{
                                ID:   c.ID,
                                Name: c.Name,
                        }
                        categories = append(categories, category)
                }</span>

                <span class="cov0" title="0">render.JSON(w, r, Response{
                        Categories: categories,
                })

                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package middlewares

import (
        "context"
        "log/slog"
        "net/http"

        "github.com/AlexMickh/coledzh-shop-backend/pkg/logger"
)

type SessionValidator interface {
        ValidateAdminSession(ctx context.Context, sessionId string) error
}

func Admin(sessionValidator SessionValidator) func(next http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        const op = "middlewares.Auth"
                        ctx := r.Context()
                        log := logger.FromCtx(ctx).With(slog.String("op", op))

                        session, err := r.Cookie("session_id")
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("failed to get session", logger.Err(err))
                                w.WriteHeader(http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov0" title="0">err = sessionValidator.ValidateAdminSession(ctx, session.Value)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("failed to validate session", logger.Err(err))
                                w.WriteHeader(http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package server

import (
        "context"
        "fmt"
        "net/http"

        _ "github.com/AlexMickh/coledzh-shop-backend/docs"
        "github.com/AlexMickh/coledzh-shop-backend/internal/config"
        "github.com/AlexMickh/coledzh-shop-backend/internal/lib/email"
        "github.com/AlexMickh/coledzh-shop-backend/internal/models"
        "github.com/AlexMickh/coledzh-shop-backend/internal/server/handlers/auth/login"
        "github.com/AlexMickh/coledzh-shop-backend/internal/server/handlers/auth/register"
        "github.com/AlexMickh/coledzh-shop-backend/internal/server/handlers/auth/verify"
        create_category "github.com/AlexMickh/coledzh-shop-backend/internal/server/handlers/category/create"
        get_category "github.com/AlexMickh/coledzh-shop-backend/internal/server/handlers/category/get"
        "github.com/AlexMickh/coledzh-shop-backend/internal/server/middlewares"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/api"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/logger"
        "github.com/AlexMickh/coledzh-shop-backend/pkg/session"
        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "github.com/go-playground/validator/v10"
        "github.com/rs/cors"
        httpSwagger "github.com/swaggo/http-swagger/v2"
)

type Server struct {
        srv *http.Server
}

type AuthService interface {
        Register(ctx context.Context, login, email, password string) (string, error)
        Login(ctx context.Context, email, password string) (string, error)
}

type TokenService interface {
        CreateToken(ctx context.Context, userId, tokenType string) (string, error)
        VerifyEmail(ctx context.Context, token string) error
}

type CategoryService interface {
        CreateCategory(ctx context.Context, name string) (string, error)
        AllCategories(ctx context.Context) ([]models.Category, error)
}

type UserService interface {
        ValidateAdminSession(ctx context.Context, sessionId string) error
}

// @title                                                Your API
// @version                                        1.0
// @description                                Your API description
// @securityDefinitions.apikey        SessionAuth
// @in                                                        cookie
// @name                                                session_id
func New(
        ctx context.Context,
        cfg config.ServerConfig,
        authService AuthService,
        mailCfg config.MailConfig,
        tokenService TokenService,
        categoryService CategoryService,
        userService UserService,
) *Server <span class="cov0" title="0">{
        const op = "server.New"

        r := chi.NewRouter()

        validator := validator.New()
        email := email.New(mailCfg)
        session := session.New("session_id", true, false, 60*60*24*5)

        r.Use(cors.New(cors.Options{
                AllowedOrigins:   []string{"*"},
                AllowCredentials: true,
        }).Handler)

        r.Use(middleware.RequestID)
        r.Use(logger.ChiMiddleware(ctx))
        r.Use(middleware.Recoverer)
        // r.Use(middleware.URLFormat)

        r.Get("/swagger/*", httpSwagger.Handler(
                httpSwagger.URL(fmt.Sprintf("http://%s/swagger/doc.json", cfg.Addr)), //The url pointing to API definition
        ))

        r.Get("/health-check", api.ErrorWrapper(func(w http.ResponseWriter, r *http.Request) error </span><span class="cov0" title="0">{
                logger.FromCtx(r.Context()).Info("hello")
                w.WriteHeader(200)
                return nil
        }</span>))

        <span class="cov0" title="0">r.Route("/auth", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Post("/register", api.ErrorWrapper(register.New(validator, authService, tokenService, email)))
                r.Post("/login", api.ErrorWrapper(login.New(authService, *validator, session)))
                r.Get("/verify/{token}", api.ErrorWrapper(verify.New(tokenService)))
        }</span>)

        <span class="cov0" title="0">r.Route("/category", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Get("/", api.ErrorWrapper(get_category.New(categoryService)))
        }</span>)

        <span class="cov0" title="0">r.Route("/admin", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Use(middlewares.Admin(userService))
                r.Post("/create-category", api.ErrorWrapper(create_category.New(categoryService, validator)))
        }</span>)

        <span class="cov0" title="0">return &amp;Server{
                srv: &amp;http.Server{
                        Addr:         cfg.Addr,
                        Handler:      r,
                        ReadTimeout:  cfg.Timeout,
                        WriteTimeout: cfg.Timeout,
                        IdleTimeout:  cfg.IdleTimeout,
                },
        }</span>
}

func (s *Server) Run(ctx context.Context) error <span class="cov0" title="0">{
        const op = "server.Run"

        if err := s.srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Server) GracefulStop(ctx context.Context) error <span class="cov0" title="0">{
        const op = "server.GracefulStop"

        if err := s.srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Server) Addr() string <span class="cov0" title="0">{
        return s.srv.Addr
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package auth_service

import (
        "context"
        "fmt"

        "github.com/AlexMickh/coledzh-shop-backend/internal/errs"
        "github.com/AlexMickh/coledzh-shop-backend/internal/models"
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

type Storage interface {
        SaveUser(ctx context.Context, login, email, password string) (string, error)
        SaveAdmin(ctx context.Context, login, email, password string) error
        UserByEmail(ctx context.Context, email string) (models.User, error)
        VerifyEmail(ctx context.Context, id string) error
}

type SessionStore interface {
        SaveSession(ctx context.Context, id string, user models.User) error
}

type Service struct {
        storage      Storage
        sessionStore SessionStore
}

func New(storage Storage, sessionStore SessionStore) *Service <span class="cov0" title="0">{
        return &amp;Service{
                storage:      storage,
                sessionStore: sessionStore,
        }
}</span>

func (s *Service) Register(ctx context.Context, login, email, password string) (string, error) <span class="cov8" title="1">{
        const op = "services.auth.Register"

        hashPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">id, err := s.storage.SaveUser(ctx, login, email, string(hashPassword))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return id, nil</span>
}

func (s *Service) RegisterAdmin(ctx context.Context, login, email, password string) error <span class="cov8" title="1">{
        const op = "services.auth.Register"

        hashPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">err = s.storage.SaveAdmin(ctx, login, email, string(hashPassword))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *Service) Login(ctx context.Context, email, password string) (string, error) <span class="cov8" title="1">{
        const op = "services.auth.Login"

        user, err := s.storage.UserByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">if !user.IsEmailVerified </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", op, errs.ErrEmailNotVerify)
        }</span>

        <span class="cov8" title="1">err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", op, errs.ErrUserNotFound)
        }</span>

        <span class="cov8" title="1">sessionId := uuid.NewString()
        err = s.sessionStore.SaveSession(ctx, sessionId, user)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return sessionId, nil</span>
}

// TODO: move to user service
func (s *Service) VerifyEmail(ctx context.Context, id string) error <span class="cov0" title="0">{
        const op = "services.auth.VerifyEmail"

        err := s.storage.VerifyEmail(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package category_service

import (
        "context"
        "fmt"
        "slices"
        "sort"

        "github.com/AlexMickh/coledzh-shop-backend/internal/errs"
        "github.com/AlexMickh/coledzh-shop-backend/internal/models"
        "github.com/google/uuid"
)

type Repository interface {
        SaveCategory(ctx context.Context, id string, name string) error
        AllCategories(ctx context.Context) ([]models.Category, error)
}

type Cash interface {
        SaveCategory(ctx context.Context, categoty models.Category) error
        AllCategories(ctx context.Context) ([]models.Category, error)
}

type Service struct {
        repository Repository
        cash       Cash
}

func New(repository Repository, cash Cash) *Service <span class="cov0" title="0">{
        return &amp;Service{
                repository: repository,
                cash:       cash,
        }
}</span>

func (s *Service) CreateCategory(ctx context.Context, name string) (string, error) <span class="cov8" title="1">{
        const op = "services.category.CreateCategory"

        id := uuid.NewString()
        err := s.repository.SaveCategory(ctx, id, name)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">err = s.cash.SaveCategory(ctx, models.Category{ID: id, Name: name})
        if err != nil </span><span class="cov0" title="0">{
                return id, fmt.Errorf("%s: %w", op, errs.ErrFailedToCash)
        }</span>

        <span class="cov8" title="1">return id, nil</span>
}

func (s *Service) AllCategories(ctx context.Context) ([]models.Category, error) <span class="cov0" title="0">{
        const op = "services.category.AllCategories"

        categories, err := s.cash.AllCategories(ctx)
        if err == nil </span><span class="cov0" title="0">{
                sortCategories(categories)
                return categories, nil
        }</span>

        <span class="cov0" title="0">categories, err = s.repository.AllCategories(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov0" title="0">sortCategories(categories)

        return categories, nil</span>
}

func sortCategories(arr []models.Category) <span class="cov0" title="0">{
        slices.SortFunc(arr, func(a models.Category, b models.Category) int </span><span class="cov0" title="0">{
                arr := []string{a.Name, b.Name}
                sort.Strings(arr)
                if arr[0] == a.Name </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">return 1</span>
        })
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package token_service

import (
        "context"
        "fmt"

        "github.com/AlexMickh/coledzh-shop-backend/internal/consts"
        "github.com/AlexMickh/coledzh-shop-backend/internal/errs"
        "github.com/google/uuid"
)

type Storage interface {
        SaveToken(ctx context.Context, userId, token, tokenType string) error
        UserIdByToken(ctx context.Context, token, tokenType string) (string, error)
}

type UserService interface {
        VerifyEmail(ctx context.Context, id string) error
}

type Service struct {
        storage     Storage
        userService UserService
}

func New(storage Storage, userService UserService) *Service <span class="cov0" title="0">{
        return &amp;Service{
                storage:     storage,
                userService: userService,
        }
}</span>

func (s *Service) CreateToken(ctx context.Context, userId, tokenType string) (string, error) <span class="cov8" title="1">{
        const op = "services.token.CreateToken"

        var token string
        switch tokenType </span>{
        case consts.TokenTypeEmailVerify:<span class="cov8" title="1">
                token = uuid.NewString()</span>
        default:<span class="cov8" title="1">
                return "", fmt.Errorf("%s: %w", op, errs.ErrWrongTokenType)</span>
        }

        <span class="cov8" title="1">err := s.storage.SaveToken(ctx, userId, token, tokenType)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return token, nil</span>
}

func (s *Service) VerifyEmail(ctx context.Context, token string) error <span class="cov0" title="0">{
        const op = "services.token.ValidateEmail"

        userId, err := s.storage.UserIdByToken(ctx, token, consts.TokenTypeEmailVerify)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">err = s.userService.VerifyEmail(ctx, userId)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package user_service

import (
        "context"
        "fmt"

        "github.com/AlexMickh/coledzh-shop-backend/internal/consts"
        "github.com/AlexMickh/coledzh-shop-backend/internal/errs"
        "github.com/AlexMickh/coledzh-shop-backend/internal/models"
)

type SessionRepository interface {
        SessionById(ctx context.Context, sessionId string) (models.User, error)
}

type Service struct {
        sessionRepository SessionRepository
}

func New(sessionRepository SessionRepository) *Service <span class="cov0" title="0">{
        return &amp;Service{
                sessionRepository: sessionRepository,
        }
}</span>

func (s *Service) ValidateAdminSession(ctx context.Context, sessionId string) error <span class="cov0" title="0">{
        const op = "services.user.ValidateAdminSession"

        user, err := s.sessionRepository.SessionById(ctx, sessionId)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">if user.Role != consts.RoleAdmin </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, errs.ErrNotAdmin)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package api

import (
        "net/http"

        "github.com/go-chi/render"
)

type HttpError struct {
        error
        msg    string
        status int
}

type ErrorResponse struct {
        Error string `json:"error"`
}

type HandlerFunc func(w http.ResponseWriter, r *http.Request) error

func ErrorWrapper(f func(w http.ResponseWriter, r *http.Request) error) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                err := f(w, r)
                if err != nil </span><span class="cov0" title="0">{
                        w.Header().Add("Content-Type", "application/json")
                        httpErr, ok := err.(HttpError)
                        if ok </span><span class="cov0" title="0">{
                                w.WriteHeader(httpErr.status)
                                render.JSON(w, r, ErrorResponse{Error: httpErr.msg})
                        }</span> else<span class="cov0" title="0"> {
                                w.WriteHeader(http.StatusInternalServerError)
                                render.JSON(w, r, ErrorResponse{Error: err.Error()})
                        }</span>
                }
        }
}

func Error(msg string, status int) HttpError <span class="cov0" title="0">{
        return HttpError{
                msg:    msg,
                status: status,
        }
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package postgresql

import (
        "context"
        "fmt"
        "time"

        "github.com/AlexMickh/coledzh-shop-backend/pkg/utils/retry"
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        "github.com/jackc/pgx/v5/pgxpool"
)

func New(
        ctx context.Context,
        username string,
        password string,
        host string,
        port int,
        database string,
        minPools int,
        maxPools int,
        migrationsPath string,
) (*pgxpool.Pool, error) <span class="cov0" title="0">{
        const op = "postgres-client.New"

        var pool *pgxpool.Pool

        err := retry.WithDelay(5, 500*time.Millisecond, func() error </span><span class="cov0" title="0">{
                var err error

                connString := fmt.Sprintf(
                        "postgres://%s:%s@%s:%d/%s?sslmode=disable&amp;pool_max_conns=%d&amp;pool_min_conns=%d",
                        username,
                        password,
                        host,
                        port,
                        database,
                        maxPools,
                        minPools,
                )

                pool, err = pgxpool.New(ctx, connString)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", op, err)
                }</span>

                <span class="cov0" title="0">err = pool.Ping(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", op, err)
                }</span>

                // m, err := migrate.New(
                //         "file://"+migrationsPath,
                //         strings.Split(connString, "&amp;")[0],
                // )
                // if err != nil {
                //         return fmt.Errorf("%s: %w", op, err)
                // }

                // if err = m.Up(); err != nil &amp;&amp; !errors.Is(err, migrate.ErrNoChange) {
                //         return fmt.Errorf("%s: %w", op, err)
                // }

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return pool, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package redis_client

import (
        "context"
        "fmt"
        "time"

        "github.com/AlexMickh/coledzh-shop-backend/pkg/utils/retry"
        "github.com/redis/go-redis/v9"
)

func New(
        ctx context.Context,
        addr string,
        user string,
        password string,
        db int,
) (*redis.Client, error) <span class="cov0" title="0">{
        const op = "redis-client.New"

        var rdb *redis.Client

        err := retry.WithDelay(5, 500*time.Millisecond, func() error </span><span class="cov0" title="0">{
                rdb = redis.NewClient(&amp;redis.Options{
                        Addr:     addr,
                        Password: password,
                        DB:       db,
                })

                err := rdb.Ping(ctx).Err()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", op, err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return rdb, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package logger

import (
        "context"
        "io"
        "log/slog"
        "net/http"
        "time"

        "github.com/go-chi/chi/v5/middleware"
)

type key string

var (
        Key       = key("logger")
        RequestID = "request_id"
)

func New(env string, w io.Writer) *slog.Logger <span class="cov0" title="0">{
        var log *slog.Logger

        switch env </span>{
        case "local":<span class="cov0" title="0">
                log = slog.New(
                        slog.NewTextHandler(w, &amp;slog.HandlerOptions{Level: slog.LevelDebug}),
                )</span>
        case "dev":<span class="cov0" title="0">
                log = slog.New(
                        slog.NewJSONHandler(w, &amp;slog.HandlerOptions{Level: slog.LevelDebug}),
                )</span>
        case "prod":<span class="cov0" title="0">
                log = slog.New(
                        slog.NewJSONHandler(w, &amp;slog.HandlerOptions{Level: slog.LevelInfo}),
                )</span>
        default:<span class="cov0" title="0">
                log = slog.Default()</span>
        }

        <span class="cov0" title="0">return log</span>
}

func Err(err error) slog.Attr <span class="cov0" title="0">{
        return slog.Attr{
                Key:   "error",
                Value: slog.StringValue(err.Error()),
        }
}</span>

func ContextWithLogger(ctx context.Context, log *slog.Logger) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, Key, log)
}</span>

func FromCtx(ctx context.Context) *slog.Logger <span class="cov0" title="0">{
        log, ok := ctx.Value(Key).(*slog.Logger)
        if !ok </span><span class="cov0" title="0">{
                return slog.Default()
        }</span>

        <span class="cov0" title="0">return log</span>
}

func ChiMiddleware(ctx context.Context) func(next http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                log := FromCtx(ctx)

                log.Info("logger middleware enabled")

                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        guid := middleware.GetReqID(r.Context())
                        ctx = context.WithValue(r.Context(), RequestID, guid)
                        log = log.With(slog.String("request_id", guid))
                        log.Info(
                                "new request",
                                slog.String("method", r.Method),
                                slog.String("path", r.URL.Path),
                                slog.String("remove_addr", r.RemoteAddr),
                                slog.String("user_agent", r.UserAgent()),
                        )
                        ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)

                        t1 := time.Now()
                        defer func() </span><span class="cov0" title="0">{
                                FromCtx(ctx).Info("request completed",
                                        slog.Int("status", ww.Status()),
                                        slog.Int("bytes", ww.BytesWritten()),
                                        slog.String("duration", time.Since(t1).String()),
                                )
                        }</span>()

                        <span class="cov0" title="0">ctx = context.WithValue(ctx, Key, log)
                        r = r.WithContext(ctx)

                        next.ServeHTTP(ww, r)</span>
                }

                <span class="cov0" title="0">return http.HandlerFunc(fn)</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package session

import "net/http"

type Session struct {
        name     string
        httpOnly bool
        secure   bool
        maxAge   int
}

func New(
        name string,
        httpOnly bool,
        secure bool,
        maxAge int,
) *Session <span class="cov0" title="0">{
        return &amp;Session{
                name:     name,
                httpOnly: httpOnly,
                secure:   secure,
                maxAge:   maxAge,
        }
}</span>

func (s *Session) Create(w http.ResponseWriter, sessionId string) <span class="cov0" title="0">{
        cookie := &amp;http.Cookie{
                Name:     s.name,
                Value:    sessionId,
                Path:     "/",
                HttpOnly: s.httpOnly,
                Secure:   s.secure,
                SameSite: http.SameSiteStrictMode,
                MaxAge:   s.maxAge,
        }
        http.SetCookie(w, cookie)
        w.WriteHeader(http.StatusCreated)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package retry

import "time"

func WithDelay(maxAttempts int, delay time.Duration, fn func() error) error <span class="cov0" title="0">{
        var err error

        for maxAttempts &gt; 0 </span><span class="cov0" title="0">{
                if err = fn(); err != nil </span><span class="cov0" title="0">{
                        time.Sleep(delay)
                        maxAttempts--
                        continue</span>
                }

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
